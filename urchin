#!/bin/sh

# This file is part of urchin. It is subject to the license terms in the
# COPYING file found in the top-level directory of this distribution or at
# https://raw.githubusercontent.com/tlevine/urchin/master/COPYING

# No part of urchin, including this file, may be copied, modified, propagated,
# or distributed except according to the terms contained in the COPYING file.

set -e

# Make sure that CDPATH isn't set, as it causes `cd` to behave unpredictably -
# notably, it can produce output, which breaks fullpath().
unset CDPATH

# Urchin version number
VERSION=0.0.6

urchin_root() {
  # Call recursively but remember the original argument.
  current="$(remove_trailing_slash "$1")"
  if test -n "$2"; then
    orig="$2"
  else
    orig="$1"
  fi

  if ! test -e "$current"; then
    echo "$current: No such file or directory">&2
    return 1
  elif test -f "$current"; then
    urchin_root "$(dirname "$current")" "$orig"
  elif test -d "$current"/.urchin; then
    remove_trailing_slash "$current"
  elif test "$(readlink -f "$current")" = / ||
    echo "$current" | grep '^\.[^.]' > /dev/null; then
  echo "$current" > /tmp/aaa
    # Stop traversing upwards at / and at hidden directories.
    if test -d "$orig"; then
      origdir="$orig"
    else
      origdir=$(dirname "$orig")
    fi
    echo "You need to create the .urchin directory in the root of your tests,
maybe like this:

  mkdir '$(remove_trailing_slash "$origdir")/.urchin'
" >&2
    return 1
  else
    urchin_root "$current"/.. "$orig"
  fi
}

indent() {
  level="$1"
  if test "$level" -gt 0; then
    printf "%$((2 * ${level}))s"
  fi
}

remove_trailing_slash() {
  echo "$1" | sed s/\\/$//
}

escape_slashes() {
  echo "$1" | sed s+/+\\\\/+g
}

get_stdout_file() {
  root="$(readlink -f "$(urchin_root "$1")")"
  test_file="$(readlink -f "$1")"
  eroot="$(escape_slashes "$root")"
  base="$(echo "$test_file" | sed "s/^$eroot/$eroot\/.urchin/")"
  if test -d "$1"; then
    echo "$base"/.index
  else
    echo "$base"
  fi
}

recurse() {
  potential_test="$1"
  indent_level="$2"
  shell_for_sh_tests="$3"

  [ "$potential_test" = '.urchin' ] && return
  [ "$potential_test" = 'setup_dir' ] && return
  [ "$potential_test" = 'teardown_dir' ] && return
  [ "$potential_test" = 'setup' ] && return
  [ "$potential_test" = 'teardown' ] && return

  stdout_file="$(get_stdout_file "$potential_test")"
  mkdir -p "$(dirname "$stdout_file")"

  [ $indent_level -eq 0 ] && : > "$stdout_file"

  if [ -d "$potential_test" ]
    then

    if $tap_format; then
      indent $indent_level | sed 's/  /#/g'
      echo "# Begin - ${potential_test}"
    else
      indent $indent_level
      echo "+ ${potential_test}"
    fi

    (
      cd -- "$potential_test"
      [ -f setup_dir ] && [ -x setup_dir ] && ./setup_dir >> "$stdout_file"

      if [ -n "$ZSH_VERSION" ]; then
        # avoid "no matches found: *" error when directories are empty
        setopt NULL_GLOB
      fi

      for test in *
        do
        [ -f setup ] && [ -x setup ] && ./setup >> "$stdout_file"

        # $2 instead of $indent_level so it doesn't clash
        set +e
        recurse "${test}" "$(( $2 + 1 ))" "$shell_for_sh_tests"
        exit_code=$?
        set -e

        if $exit_on_fail && test $exit_code -ne 0; then
          [ -f teardown ] && [ -x teardown ] && ./teardown >> "$stdout_file"
          [ -f teardown_dir ] && [ -x teardown_dir ] && ./teardown_dir >> "$stdout_file"
          return 1
        fi

        [ -f teardown ] && [ -x teardown ] && ./teardown >> "$stdout_file"
      done
      [ -f teardown_dir ] && [ -x teardown_dir ] && ./teardown_dir >> "$stdout_file"
    )
    if $tap_format; then
      indent $indent_level | sed 's/  /#/g'
      echo "# End - ${potential_test}"
    else
      echo
    fi
  else
    if [ -x "$potential_test" ]
      then
      [ -f setup ] && [ -x setup ] && ./setup >> "$stdout_file"

      # Run the test
      if [ -n "$shell_for_sh_tests" ] && has_sh_or_no_shebang_line ./"$potential_test"
        then    
        TEST_SHELL="$TEST_SHELL" "$shell_for_sh_tests" ./"$potential_test" > "$stdout_file" 2>&1
      else
        TEST_SHELL="$TEST_SHELL" ./"$potential_test" > "$stdout_file" 2>&1
      fi
      exit_code="$?"

      [ -f teardown ] && [ -x teardown ] && ./teardown >> "$stdout_file"
      if [ $exit_code -eq 0 ]; then
        result=success
      elif [ $exit_code -eq 3 ]; then
        result=skip
      else
        result=fail
      fi
    else
      result=skip
    fi

    echo "${result}" >> "$logfile"
    if $tap_format; then
      n=$(grep -ce '^\(success\|fail\|skip\)' "$logfile")

      if [ "$result" == fail ]; then
        not='not '
      else
        not=''
      fi
      if [ "$result" == skip ]; then
        skip='# SKIP '
      else
        skip=''
      fi
      echo "${not}ok $n - ${skip}${potential_test}"
      if [ "$result" == fail ]; then
        echo '# ------------ Begin output ------------'
        sed 's/^/# /' "$stdout_file"
        echo '# ------------ End output ------------'
      fi
    else
      indent $indent_level
      case "$result" in
        success)
          # On success, print a green '✓'
          printf '\033[32m✓ \033[0m'
          printf '%s\n' "${potential_test}"
        ;;
        fail)
          # On fail, print a red '✗'
          printf '\033[31m✗ \033[0m'
          printf '%s\n' "${potential_test}"

          # Print output captured from failed test in red.
          printf '\033[31m'

          cat "$stdout_file"
          printf '\033[0m'
        ;;
        skip)
          printf '  %s\n' "${potential_test}"
        ;;
      esac
    fi

    if $exit_on_fail && test 0 -ne $exit_code; then
      return 1
    fi
  fi
}

has_sh_or_no_shebang_line() {
  # no shebang line at all
  head -n 1 "$1" | grep -vqE '^#!' && return 0

  # shebang line is '#!/bin/sh' or legal variations thereof
  head -n 1 "$1" | grep -qE '^#![[:blank:]]*/bin/sh($|[[:blank:]])' &&
    return 0  

  return 1
}

USAGE="usage: $0 [<options>] <test directory>"

urchin_help() {
  cat <<EOF

$USAGE

-s <shell>  Invoke test scripts that either have no shebang line at all or
            have shebang line "#!/bin/sh" with the specified shell.
-e          Stop running if any single test fails. This is helpful if you want
            to use Urchin to run things other than tests, such as a set of
            configuration scripts.
-f          Force running even if the test directory's name does not
            contain the word "test".
-t          Format output in Test Anything Protocol (TAP)
-h, --help  This help.
-r, --root  Print the Urchin root for a particular file or directory.
-v          Display the version number.

Go to https://github.com/tlevine/urchin for documentation on writing tests.

EOF
}

plural () {
  # Make $1 a plural according to the number $2.
  # If $3 is supplied, use that instead of "${1}s".
  # Result is written to stdout.
  if [ "$2" = 1 ]
  then
    printf '%s\n' "$1"
  else
    printf '%s\n' "${3-${1}s}"
  fi
}

urchin_go() {
  if "$tap_format"; then
    printf \#\ 
  fi
  echo Running tests at $(date +%Y-%m-%dT%H:%M:%S)
  start="$(date +%s)"

  # Determine the environment variable to define for test scripts
  # that reflects the specified or implied shell to use for shell-code tests.
  #  - Set it to the shell specified via -s, if any.
  #  - Otherwise, use its present value, if non-empty.
  #  - Otherwise, default to '/bin/sh'.
  if [ -n "$2" ]
    then
    TEST_SHELL="$2"
  elif [ -z "$TEST_SHELL" ]
    then
    TEST_SHELL='/bin/sh'
  fi

  recurse "$1" 0 "$2"  # test folder -- indentation level -- [shell to invoke test scripts with]

  finish=$(date +%s)
  elapsed=$(($finish - $start))

  passed=$(grep -c '^success' "$logfile")
  failed=$(grep -c '^fail' "$logfile")
  skipped=$(grep -c '^skip' "$logfile")
  if $tap_format; then
    echo "# Took $elapsed $(plural second $elapsed)."
    echo 1..$(($passed + $failed + $skipped))
  else
    echo "Done, took $elapsed $(plural second $elapsed)."
    printf '%s\n' "$passed $(plural test "$passed") passed."
    printf '%s\n' "$skipped $(plural test "$skipped") skipped."

    # If tests failed, print the message in red, otherwise in green.
    [ $failed -gt 0 ] && printf '\033[31m' || printf '\033[32m'

    printf '%s\n' "$failed $(plural test "$failed") failed."
    printf '\033[m'
  fi
# rm -f "$logfile"
  test -z "$failed" || test "$failed" -eq '0'
}

urchin_molly_guard() {
  {
    echo
    echo 'The name of the directory on which you are running urchin'
    echo 'does not contain the word "test", so I am not running,'
    echo 'in case that was an accident. Use the -f flag if you really'
    echo 'want to run urchin on that directory.'
    echo
  } >&2
  exit 1
}

if test -z "$I_AM_SOURCING_URCHIN_IN_A_TEST"; then
  shell_for_sh_tests=
  force=false
  exit_on_fail=false
  tap_format=false
  while [ $# -gt 0 ]
  do
      case "$1" in
          -e) exit_on_fail=true;;
          -f) force=true;;
          -r|--root)
            shift
            urchin_root "$1"
            exit;;
          -s)
            shift
            shell_for_sh_tests=$1
            which "$shell_for_sh_tests" > /dev/null || {
              echo "Cannot find specified shell: '$shell_for_sh_tests'" >&2
              urchin_help >&2
              exit 11
            } ;;
          -t) tap_format=true;;
          -h|--help) urchin_help
            exit 0;;
          -v) echo "$VERSION"
              exit;;
          -*) urchin_help >&2
              exit 1;;
          *)  break;;
      esac
      shift
  done

  # Verify argument for main stuff
  if [ "$#" != '1' ] || [ ! -d "$1" ]
    then
    [ -n "$1" ] && [ ! -d "$1" ] && echo "Not a directory: '$1'" >&2
    echo "$USAGE" >&2
    exit 11
  fi

  # Run or present the Molly guard.
  if ! urchin_root "$1" > /dev/null; then
    exit 1
  elif basename "$(readlink -f "$(urchin_root "$1")")" |
    grep -Fi 'test' > /dev/null || $force; then
    logfile="$(readlink -f "$(urchin_root "$1")/.urchin/.log")"
    printf '' > "$logfile"
    urchin_go "$1" "$shell_for_sh_tests"
  else
    urchin_molly_guard
  fi
fi
