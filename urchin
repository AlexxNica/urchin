#!/bin/sh

# This file is part of urchin. It is subject to the license terms in the
# COPYING file found in the top-level directory of this distribution or at
# https://raw.githubusercontent.com/tlevine/urchin/master/COPYING

# No part of urchin, including this file, may be copied, modified, propagated,
# or distributed except according to the terms contained in the COPYING file.

set -e

# Make sure that CDPATH isn't set, as it causes `cd` to behave unpredictably -
# notably, it can produce output.
unset CDPATH

# All temporary files go here
tmp=$(mktemp -d)
urchin_exit() {
  echo rm -f "$tmp"
# rm -f "$tmp"
  exit "$@"
}

# Expand relative paths
alias fullpath='readlink -f --'

# Urchin version number
VERSION=0.1.0-rc1

indent() {
  level="$1"
  if test "$level" -gt 0; then
    printf "%$((2 * ${level}))s"
  fi
}

recurse() {
  potential_test="$1"
  indent_level="$2"
  shell_for_sh_tests="$3"

  [ "$potential_test" = 'setup_dir' ] && return
  [ "$potential_test" = 'teardown_dir' ] && return
  [ "$potential_test" = 'setup' ] && return
  [ "$potential_test" = 'teardown' ] && return

  if [ -d "$potential_test" ]; then
    (
      cd -- "$potential_test"
      [ -f setup_dir ] && . ./setup_dir > /dev/null

      if [ -n "$ZSH_VERSION" ]; then
        # avoid "no matches found: *" error when directories are empty
        setopt NULL_GLOB
      fi

      for test in *; do
        [ -f setup ] && . ./setup > /dev/null

        set +e
        # $2 instead of $indent_level so it doesn't clash
        recurse "${test}" $(( $2 + 1 )) "$shell_for_sh_tests"
        exit_code=$?
        set -e

        if $exit_on_fail && test $exit_code -ne 0; then
          [ -f teardown ] && . ./teardown > /dev/null
          [ -f teardown_dir ] && . ./teardown_dir > /dev/null
          exit 1 # Exit the sub-shell
        fi

        [ -f teardown ] && . ./teardown > /dev/null
      done
      [ -f teardown_dir ] && . ./teardown_dir > /dev/null
    )
  else
    stdout_file="$tmp/stdout$(fullpath "$potential_test")"
    mkdir -p "$(dirname "$stdout_file")"
    > $stdout_file
    if [ -x "$potential_test" ]; then
      [ -f setup ] && . ./setup > /dev/null

      # Run the test
      set +e
      if [ -n "$shell_for_sh_tests" ] && has_sh_or_no_shebang_line ./"$potential_test"; then
        TEST_SHELL="$TEST_SHELL" "$shell_for_sh_tests" ./"$potential_test" > "$stdout_file" 2>&1
      else
        TEST_SHELL="$TEST_SHELL" ./"$potential_test" > "$stdout_file" 2>&1
      fi
      exit_code="$?"
      set -e

      [ -f teardown ] && . ./teardown > /dev/null
      if [ $exit_code -eq 0 ]; then
        result=success
      elif [ $exit_code -eq 3 ]; then
        result=skip
      else
        result=fail
      fi
    else
      result=skip
    fi

    printf "${potential_test}\t${result}\n" >> "$tmp"/log
    if $exit_on_fail && test 0 -ne $exit_code; then
      return 1
    fi
  fi
}

report_outcome() {
  # XXX just copied from elsewhere and thus broken

  if $tap_format; then
    indent $indent_level | sed 's/  /#/g'
    echo "# Begin - ${potential_test}"
  else
    indent $indent_level
    echo "+ ${potential_test}"
  fi


  if $tap_format; then
    indent $indent_level | sed 's/  /#/g'
    echo "# End - ${potential_test}"
  else
    echo
  fi



  if $tap_format; then
    n=$(grep -ce '^\(success\|fail\|skip\)' "$logfile")

    if [ "$result" == fail ]; then
      not='not '
    else
      not=''
    fi
    if [ "$result" == skip ]; then
      skip='# SKIP '
    else
      skip=''
    fi
    echo "${not}ok $n - ${skip}${potential_test}"
    if [ "$result" == fail ]; then
      echo '# ------------ Begin output ------------'
      sed 's/^/# /' "$stdout_file"
      echo '# ------------ End output ------------'
    fi
  else
    indent $indent_level
    case "$result" in
      success)
        # On success, print a green '✓'
        printf '\033[32m✓ \033[0m'
        printf '%s\n' "${potential_test}"
      ;;
      fail)
        # On fail, print a red '✗'
        printf '\033[31m✗ \033[0m'
        printf '%s\n' "${potential_test}"

        # Print output captured from failed test in red.
        printf '\033[31m'

        cat "$stdout_file"
        printf '\033[0m'
      ;;
      skip)
        printf '  %s\n' "${potential_test}"
      ;;
    esac
  fi
  rm $stdout_file




  finish=$(date +%s)
  elapsed=$(($finish - $start))

  set +e
  passed=$(grep -c '^success' "$logfile")
  failed=$(grep -c '^fail' "$logfile")
  skipped=$(grep -c '^skip' "$logfile")
  if $tap_format; then
    echo "# Took $elapsed $(plural second $elapsed)."
    echo 1..$(($passed + $failed + $skipped))
  else
    echo "Done, took $elapsed $(plural second $elapsed)."
    printf '%s\n' "$passed $(plural test "$passed") passed."
    printf '%s\n' "$skipped $(plural test "$skipped") skipped."

    # If tests failed, print the message in red, otherwise in green.
    [ $failed -gt 0 ] && printf '\033[31m' || printf '\033[32m'

    printf '%s\n' "$failed $(plural test "$failed") failed."
    printf '\033[m'
  fi
  rm -f "$logfile"
  test -z "$failed" || test "$failed" -eq '0'
}

has_sh_or_no_shebang_line() {
  # no shebang line at all
  head -n 1 "$1" | grep -vqE '^#!' && return 0

  # shebang line is '#!/bin/sh' or legal variations thereof
  head -n 1 "$1" | grep -qE '^#![[:blank:]]*/bin/sh($|[[:blank:]])' &&
    return 0  

  return 1
}

USAGE="usage: $0 [<options>] <test directory>"

urchin_help() {
  cat <<EOF

$USAGE

-s <shell>  Invoke test scripts that either have no shebang line at all or
            have shebang line "#!/bin/sh" with the specified shell.
-e          Stop running if any single test fails. This is helpful if you want
            to use Urchin to run things other than tests, such as a set of
            configuration scripts.
-f          Force running even if the test directory's name does not
            contain the word "test".
-t          Format output in Test Anything Protocol (TAP)
-h, --help  This help.
-v          Display the version number.

Go to https://github.com/tlevine/urchin for documentation on writing tests.

EOF
}

plural () {
  # Make $1 a plural according to the number $2.
  # If $3 is supplied, use that instead of "${1}s".
  # Result is written to stdout.
  if [ "$2" = 1 ]
  then
    printf '%s\n' "$1"
  else
    printf '%s\n' "${3-${1}s}"
  fi
}

urchin_go() {
  if "$tap_format"; then
    printf \#\ 
  fi
  echo Running tests at $(date +%Y-%m-%dT%H:%M:%S)
  start=$(date +%s)

  # Determine the environment variable to define for test scripts
  # that reflects the specified or implied shell to use for shell-code tests.
  #  - Set it to the shell specified via -s, if any.
  #  - Otherwise, use its present value, if non-empty.
  #  - Otherwise, default to '/bin/sh'.
  if [ -n "$2" ]; then
    TEST_SHELL="$2"
  elif [ -n "$TEST_SHELL" ]; then
    :
  else
    TEST_SHELL='/bin/sh'
  fi

  # 1 test folder
  # 2 indentation level
  # 3 shell to invoke test scripts with
  recurse "$1" 0 "$2" || :
}

urchin_molly_guard() {
  {
    echo
    echo 'The name of the directory on which you are running urchin'
    echo 'does not contain the word "test", so I am not running,'
    echo 'in case that was an accident. Use the -f flag if you really'
    echo 'want to run urchin on that directory.'
    echo
  } >&2
  urchin_exit 1
}

shell_for_sh_tests=
force=false
exit_on_fail=false
tap_format=false
while [ $# -gt 0 ]
do
    case "$1" in
        -e) exit_on_fail=true;;
        -f) force=true;;
        -s)
          shift
          shell_for_sh_tests=$1
          which "$shell_for_sh_tests" > /dev/null || {
            echo "Cannot find specified shell: '$shell_for_sh_tests'" >&2
            urchin_help >&2
            urchin_exit 11
          } ;;
        -t) tap_format=true;;
        -h|--help) urchin_help
          exit 0;;
        -v) echo "$VERSION"
            urchin_exit;;
        -*) urchin_help >&2
            exit 1;;
        *)  break;;
    esac
    shift
done

# Verify argument for main stuff
if [ "$#" != '1' ] || [ ! -d "$1" ]
  then
  [ -n "$1" ] && [ ! -d "$1" ] && echo "Not a directory: '$1'" >&2
  echo "$USAGE" >&2
  urchin_exit 11
fi

# Run or present the Molly guard.
if fullpath "$1" | grep -Fi 'test' > /dev/null || $force
  then
  urchin_go "$1" "$shell_for_sh_tests"
else
  urchin_molly_guard
fi
urchin_exit
